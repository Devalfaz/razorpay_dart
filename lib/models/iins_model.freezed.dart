// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'iins_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

IinEmi _$IinEmiFromJson(Map<String, dynamic> json) {
  return _IinEmi.fromJson(json);
}

/// @nodoc
mixin _$IinEmi {
  bool get available => throw _privateConstructorUsedError;

  /// Serializes this IinEmi to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IinEmi
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IinEmiCopyWith<IinEmi> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IinEmiCopyWith<$Res> {
  factory $IinEmiCopyWith(IinEmi value, $Res Function(IinEmi) then) =
      _$IinEmiCopyWithImpl<$Res, IinEmi>;
  @useResult
  $Res call({bool available});
}

/// @nodoc
class _$IinEmiCopyWithImpl<$Res, $Val extends IinEmi>
    implements $IinEmiCopyWith<$Res> {
  _$IinEmiCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IinEmi
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? available = null,
  }) {
    return _then(_value.copyWith(
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IinEmiImplCopyWith<$Res> implements $IinEmiCopyWith<$Res> {
  factory _$$IinEmiImplCopyWith(
          _$IinEmiImpl value, $Res Function(_$IinEmiImpl) then) =
      __$$IinEmiImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool available});
}

/// @nodoc
class __$$IinEmiImplCopyWithImpl<$Res>
    extends _$IinEmiCopyWithImpl<$Res, _$IinEmiImpl>
    implements _$$IinEmiImplCopyWith<$Res> {
  __$$IinEmiImplCopyWithImpl(
      _$IinEmiImpl _value, $Res Function(_$IinEmiImpl) _then)
      : super(_value, _then);

  /// Create a copy of IinEmi
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? available = null,
  }) {
    return _then(_$IinEmiImpl(
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(includeIfNull: false)
class _$IinEmiImpl implements _IinEmi {
  const _$IinEmiImpl({required this.available});

  factory _$IinEmiImpl.fromJson(Map<String, dynamic> json) =>
      _$$IinEmiImplFromJson(json);

  @override
  final bool available;

  @override
  String toString() {
    return 'IinEmi(available: $available)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IinEmiImpl &&
            (identical(other.available, available) ||
                other.available == available));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, available);

  /// Create a copy of IinEmi
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IinEmiImplCopyWith<_$IinEmiImpl> get copyWith =>
      __$$IinEmiImplCopyWithImpl<_$IinEmiImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$IinEmiImplToJson(
      this,
    );
  }
}

abstract class _IinEmi implements IinEmi {
  const factory _IinEmi({required final bool available}) = _$IinEmiImpl;

  factory _IinEmi.fromJson(Map<String, dynamic> json) = _$IinEmiImpl.fromJson;

  @override
  bool get available;

  /// Create a copy of IinEmi
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IinEmiImplCopyWith<_$IinEmiImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IinRecurring _$IinRecurringFromJson(Map<String, dynamic> json) {
  return _IinRecurring.fromJson(json);
}

/// @nodoc
mixin _$IinRecurring {
  bool get available => throw _privateConstructorUsedError;

  /// Serializes this IinRecurring to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IinRecurring
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IinRecurringCopyWith<IinRecurring> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IinRecurringCopyWith<$Res> {
  factory $IinRecurringCopyWith(
          IinRecurring value, $Res Function(IinRecurring) then) =
      _$IinRecurringCopyWithImpl<$Res, IinRecurring>;
  @useResult
  $Res call({bool available});
}

/// @nodoc
class _$IinRecurringCopyWithImpl<$Res, $Val extends IinRecurring>
    implements $IinRecurringCopyWith<$Res> {
  _$IinRecurringCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IinRecurring
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? available = null,
  }) {
    return _then(_value.copyWith(
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IinRecurringImplCopyWith<$Res>
    implements $IinRecurringCopyWith<$Res> {
  factory _$$IinRecurringImplCopyWith(
          _$IinRecurringImpl value, $Res Function(_$IinRecurringImpl) then) =
      __$$IinRecurringImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool available});
}

/// @nodoc
class __$$IinRecurringImplCopyWithImpl<$Res>
    extends _$IinRecurringCopyWithImpl<$Res, _$IinRecurringImpl>
    implements _$$IinRecurringImplCopyWith<$Res> {
  __$$IinRecurringImplCopyWithImpl(
      _$IinRecurringImpl _value, $Res Function(_$IinRecurringImpl) _then)
      : super(_value, _then);

  /// Create a copy of IinRecurring
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? available = null,
  }) {
    return _then(_$IinRecurringImpl(
      available: null == available
          ? _value.available
          : available // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(includeIfNull: false)
class _$IinRecurringImpl implements _IinRecurring {
  const _$IinRecurringImpl({required this.available});

  factory _$IinRecurringImpl.fromJson(Map<String, dynamic> json) =>
      _$$IinRecurringImplFromJson(json);

  @override
  final bool available;

  @override
  String toString() {
    return 'IinRecurring(available: $available)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IinRecurringImpl &&
            (identical(other.available, available) ||
                other.available == available));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, available);

  /// Create a copy of IinRecurring
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IinRecurringImplCopyWith<_$IinRecurringImpl> get copyWith =>
      __$$IinRecurringImplCopyWithImpl<_$IinRecurringImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$IinRecurringImplToJson(
      this,
    );
  }
}

abstract class _IinRecurring implements IinRecurring {
  const factory _IinRecurring({required final bool available}) =
      _$IinRecurringImpl;

  factory _IinRecurring.fromJson(Map<String, dynamic> json) =
      _$IinRecurringImpl.fromJson;

  @override
  bool get available;

  /// Create a copy of IinRecurring
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IinRecurringImplCopyWith<_$IinRecurringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

IinAuthenticationType _$IinAuthenticationTypeFromJson(
    Map<String, dynamic> json) {
  return _IinAuthenticationType.fromJson(json);
}

/// @nodoc
mixin _$IinAuthenticationType {
  String get type => throw _privateConstructorUsedError;

  /// Serializes this IinAuthenticationType to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of IinAuthenticationType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $IinAuthenticationTypeCopyWith<IinAuthenticationType> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IinAuthenticationTypeCopyWith<$Res> {
  factory $IinAuthenticationTypeCopyWith(IinAuthenticationType value,
          $Res Function(IinAuthenticationType) then) =
      _$IinAuthenticationTypeCopyWithImpl<$Res, IinAuthenticationType>;
  @useResult
  $Res call({String type});
}

/// @nodoc
class _$IinAuthenticationTypeCopyWithImpl<$Res,
        $Val extends IinAuthenticationType>
    implements $IinAuthenticationTypeCopyWith<$Res> {
  _$IinAuthenticationTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of IinAuthenticationType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$IinAuthenticationTypeImplCopyWith<$Res>
    implements $IinAuthenticationTypeCopyWith<$Res> {
  factory _$$IinAuthenticationTypeImplCopyWith(
          _$IinAuthenticationTypeImpl value,
          $Res Function(_$IinAuthenticationTypeImpl) then) =
      __$$IinAuthenticationTypeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type});
}

/// @nodoc
class __$$IinAuthenticationTypeImplCopyWithImpl<$Res>
    extends _$IinAuthenticationTypeCopyWithImpl<$Res,
        _$IinAuthenticationTypeImpl>
    implements _$$IinAuthenticationTypeImplCopyWith<$Res> {
  __$$IinAuthenticationTypeImplCopyWithImpl(_$IinAuthenticationTypeImpl _value,
      $Res Function(_$IinAuthenticationTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of IinAuthenticationType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
  }) {
    return _then(_$IinAuthenticationTypeImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@JsonSerializable(includeIfNull: false)
class _$IinAuthenticationTypeImpl implements _IinAuthenticationType {
  const _$IinAuthenticationTypeImpl({required this.type});

  factory _$IinAuthenticationTypeImpl.fromJson(Map<String, dynamic> json) =>
      _$$IinAuthenticationTypeImplFromJson(json);

  @override
  final String type;

  @override
  String toString() {
    return 'IinAuthenticationType(type: $type)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IinAuthenticationTypeImpl &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type);

  /// Create a copy of IinAuthenticationType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$IinAuthenticationTypeImplCopyWith<_$IinAuthenticationTypeImpl>
      get copyWith => __$$IinAuthenticationTypeImplCopyWithImpl<
          _$IinAuthenticationTypeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$IinAuthenticationTypeImplToJson(
      this,
    );
  }
}

abstract class _IinAuthenticationType implements IinAuthenticationType {
  const factory _IinAuthenticationType({required final String type}) =
      _$IinAuthenticationTypeImpl;

  factory _IinAuthenticationType.fromJson(Map<String, dynamic> json) =
      _$IinAuthenticationTypeImpl.fromJson;

  @override
  String get type;

  /// Create a copy of IinAuthenticationType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$IinAuthenticationTypeImplCopyWith<_$IinAuthenticationTypeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

RazorpayIin _$RazorpayIinFromJson(Map<String, dynamic> json) {
  return _RazorpayIin.fromJson(json);
}

/// @nodoc
mixin _$RazorpayIin {
  String get iin => throw _privateConstructorUsedError;
  String get entity => throw _privateConstructorUsedError;
  String get issuer_code => throw _privateConstructorUsedError;
  String get issuer_name => throw _privateConstructorUsedError;
  bool get international => throw _privateConstructorUsedError;
  bool get is_tokenized => throw _privateConstructorUsedError;
  IinEmi get emi => throw _privateConstructorUsedError;
  IinRecurring get recurring => throw _privateConstructorUsedError;
  List<IinAuthenticationType> get authentication_types =>
      throw _privateConstructorUsedError;
  IinNetwork? get network =>
      throw _privateConstructorUsedError; // Nullable enum
  IinCardType? get type => throw _privateConstructorUsedError; // Nullable enum
  IinSubType? get sub_type =>
      throw _privateConstructorUsedError; // Nullable enum
  String? get card_iin => throw _privateConstructorUsedError;

  /// Serializes this RazorpayIin to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RazorpayIinCopyWith<RazorpayIin> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RazorpayIinCopyWith<$Res> {
  factory $RazorpayIinCopyWith(
          RazorpayIin value, $Res Function(RazorpayIin) then) =
      _$RazorpayIinCopyWithImpl<$Res, RazorpayIin>;
  @useResult
  $Res call(
      {String iin,
      String entity,
      String issuer_code,
      String issuer_name,
      bool international,
      bool is_tokenized,
      IinEmi emi,
      IinRecurring recurring,
      List<IinAuthenticationType> authentication_types,
      IinNetwork? network,
      IinCardType? type,
      IinSubType? sub_type,
      String? card_iin});

  $IinEmiCopyWith<$Res> get emi;
  $IinRecurringCopyWith<$Res> get recurring;
}

/// @nodoc
class _$RazorpayIinCopyWithImpl<$Res, $Val extends RazorpayIin>
    implements $RazorpayIinCopyWith<$Res> {
  _$RazorpayIinCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? iin = null,
    Object? entity = null,
    Object? issuer_code = null,
    Object? issuer_name = null,
    Object? international = null,
    Object? is_tokenized = null,
    Object? emi = null,
    Object? recurring = null,
    Object? authentication_types = null,
    Object? network = freezed,
    Object? type = freezed,
    Object? sub_type = freezed,
    Object? card_iin = freezed,
  }) {
    return _then(_value.copyWith(
      iin: null == iin
          ? _value.iin
          : iin // ignore: cast_nullable_to_non_nullable
              as String,
      entity: null == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String,
      issuer_code: null == issuer_code
          ? _value.issuer_code
          : issuer_code // ignore: cast_nullable_to_non_nullable
              as String,
      issuer_name: null == issuer_name
          ? _value.issuer_name
          : issuer_name // ignore: cast_nullable_to_non_nullable
              as String,
      international: null == international
          ? _value.international
          : international // ignore: cast_nullable_to_non_nullable
              as bool,
      is_tokenized: null == is_tokenized
          ? _value.is_tokenized
          : is_tokenized // ignore: cast_nullable_to_non_nullable
              as bool,
      emi: null == emi
          ? _value.emi
          : emi // ignore: cast_nullable_to_non_nullable
              as IinEmi,
      recurring: null == recurring
          ? _value.recurring
          : recurring // ignore: cast_nullable_to_non_nullable
              as IinRecurring,
      authentication_types: null == authentication_types
          ? _value.authentication_types
          : authentication_types // ignore: cast_nullable_to_non_nullable
              as List<IinAuthenticationType>,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as IinNetwork?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as IinCardType?,
      sub_type: freezed == sub_type
          ? _value.sub_type
          : sub_type // ignore: cast_nullable_to_non_nullable
              as IinSubType?,
      card_iin: freezed == card_iin
          ? _value.card_iin
          : card_iin // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IinEmiCopyWith<$Res> get emi {
    return $IinEmiCopyWith<$Res>(_value.emi, (value) {
      return _then(_value.copyWith(emi: value) as $Val);
    });
  }

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $IinRecurringCopyWith<$Res> get recurring {
    return $IinRecurringCopyWith<$Res>(_value.recurring, (value) {
      return _then(_value.copyWith(recurring: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RazorpayIinImplCopyWith<$Res>
    implements $RazorpayIinCopyWith<$Res> {
  factory _$$RazorpayIinImplCopyWith(
          _$RazorpayIinImpl value, $Res Function(_$RazorpayIinImpl) then) =
      __$$RazorpayIinImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String iin,
      String entity,
      String issuer_code,
      String issuer_name,
      bool international,
      bool is_tokenized,
      IinEmi emi,
      IinRecurring recurring,
      List<IinAuthenticationType> authentication_types,
      IinNetwork? network,
      IinCardType? type,
      IinSubType? sub_type,
      String? card_iin});

  @override
  $IinEmiCopyWith<$Res> get emi;
  @override
  $IinRecurringCopyWith<$Res> get recurring;
}

/// @nodoc
class __$$RazorpayIinImplCopyWithImpl<$Res>
    extends _$RazorpayIinCopyWithImpl<$Res, _$RazorpayIinImpl>
    implements _$$RazorpayIinImplCopyWith<$Res> {
  __$$RazorpayIinImplCopyWithImpl(
      _$RazorpayIinImpl _value, $Res Function(_$RazorpayIinImpl) _then)
      : super(_value, _then);

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? iin = null,
    Object? entity = null,
    Object? issuer_code = null,
    Object? issuer_name = null,
    Object? international = null,
    Object? is_tokenized = null,
    Object? emi = null,
    Object? recurring = null,
    Object? authentication_types = null,
    Object? network = freezed,
    Object? type = freezed,
    Object? sub_type = freezed,
    Object? card_iin = freezed,
  }) {
    return _then(_$RazorpayIinImpl(
      iin: null == iin
          ? _value.iin
          : iin // ignore: cast_nullable_to_non_nullable
              as String,
      entity: null == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as String,
      issuer_code: null == issuer_code
          ? _value.issuer_code
          : issuer_code // ignore: cast_nullable_to_non_nullable
              as String,
      issuer_name: null == issuer_name
          ? _value.issuer_name
          : issuer_name // ignore: cast_nullable_to_non_nullable
              as String,
      international: null == international
          ? _value.international
          : international // ignore: cast_nullable_to_non_nullable
              as bool,
      is_tokenized: null == is_tokenized
          ? _value.is_tokenized
          : is_tokenized // ignore: cast_nullable_to_non_nullable
              as bool,
      emi: null == emi
          ? _value.emi
          : emi // ignore: cast_nullable_to_non_nullable
              as IinEmi,
      recurring: null == recurring
          ? _value.recurring
          : recurring // ignore: cast_nullable_to_non_nullable
              as IinRecurring,
      authentication_types: null == authentication_types
          ? _value._authentication_types
          : authentication_types // ignore: cast_nullable_to_non_nullable
              as List<IinAuthenticationType>,
      network: freezed == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as IinNetwork?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as IinCardType?,
      sub_type: freezed == sub_type
          ? _value.sub_type
          : sub_type // ignore: cast_nullable_to_non_nullable
              as IinSubType?,
      card_iin: freezed == card_iin
          ? _value.card_iin
          : card_iin // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(includeIfNull: false)
class _$RazorpayIinImpl implements _RazorpayIin {
  const _$RazorpayIinImpl(
      {required this.iin,
      required this.entity,
      required this.issuer_code,
      required this.issuer_name,
      required this.international,
      required this.is_tokenized,
      required this.emi,
      required this.recurring,
      required final List<IinAuthenticationType> authentication_types,
      this.network,
      this.type,
      this.sub_type,
      this.card_iin})
      : _authentication_types = authentication_types;

  factory _$RazorpayIinImpl.fromJson(Map<String, dynamic> json) =>
      _$$RazorpayIinImplFromJson(json);

  @override
  final String iin;
  @override
  final String entity;
  @override
  final String issuer_code;
  @override
  final String issuer_name;
  @override
  final bool international;
  @override
  final bool is_tokenized;
  @override
  final IinEmi emi;
  @override
  final IinRecurring recurring;
  final List<IinAuthenticationType> _authentication_types;
  @override
  List<IinAuthenticationType> get authentication_types {
    if (_authentication_types is EqualUnmodifiableListView)
      return _authentication_types;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_authentication_types);
  }

  @override
  final IinNetwork? network;
// Nullable enum
  @override
  final IinCardType? type;
// Nullable enum
  @override
  final IinSubType? sub_type;
// Nullable enum
  @override
  final String? card_iin;

  @override
  String toString() {
    return 'RazorpayIin(iin: $iin, entity: $entity, issuer_code: $issuer_code, issuer_name: $issuer_name, international: $international, is_tokenized: $is_tokenized, emi: $emi, recurring: $recurring, authentication_types: $authentication_types, network: $network, type: $type, sub_type: $sub_type, card_iin: $card_iin)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RazorpayIinImpl &&
            (identical(other.iin, iin) || other.iin == iin) &&
            (identical(other.entity, entity) || other.entity == entity) &&
            (identical(other.issuer_code, issuer_code) ||
                other.issuer_code == issuer_code) &&
            (identical(other.issuer_name, issuer_name) ||
                other.issuer_name == issuer_name) &&
            (identical(other.international, international) ||
                other.international == international) &&
            (identical(other.is_tokenized, is_tokenized) ||
                other.is_tokenized == is_tokenized) &&
            (identical(other.emi, emi) || other.emi == emi) &&
            (identical(other.recurring, recurring) ||
                other.recurring == recurring) &&
            const DeepCollectionEquality()
                .equals(other._authentication_types, _authentication_types) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.sub_type, sub_type) ||
                other.sub_type == sub_type) &&
            (identical(other.card_iin, card_iin) ||
                other.card_iin == card_iin));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      iin,
      entity,
      issuer_code,
      issuer_name,
      international,
      is_tokenized,
      emi,
      recurring,
      const DeepCollectionEquality().hash(_authentication_types),
      network,
      type,
      sub_type,
      card_iin);

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RazorpayIinImplCopyWith<_$RazorpayIinImpl> get copyWith =>
      __$$RazorpayIinImplCopyWithImpl<_$RazorpayIinImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RazorpayIinImplToJson(
      this,
    );
  }
}

abstract class _RazorpayIin implements RazorpayIin {
  const factory _RazorpayIin(
      {required final String iin,
      required final String entity,
      required final String issuer_code,
      required final String issuer_name,
      required final bool international,
      required final bool is_tokenized,
      required final IinEmi emi,
      required final IinRecurring recurring,
      required final List<IinAuthenticationType> authentication_types,
      final IinNetwork? network,
      final IinCardType? type,
      final IinSubType? sub_type,
      final String? card_iin}) = _$RazorpayIinImpl;

  factory _RazorpayIin.fromJson(Map<String, dynamic> json) =
      _$RazorpayIinImpl.fromJson;

  @override
  String get iin;
  @override
  String get entity;
  @override
  String get issuer_code;
  @override
  String get issuer_name;
  @override
  bool get international;
  @override
  bool get is_tokenized;
  @override
  IinEmi get emi;
  @override
  IinRecurring get recurring;
  @override
  List<IinAuthenticationType> get authentication_types;
  @override
  IinNetwork? get network; // Nullable enum
  @override
  IinCardType? get type; // Nullable enum
  @override
  IinSubType? get sub_type; // Nullable enum
  @override
  String? get card_iin;

  /// Create a copy of RazorpayIin
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RazorpayIinImplCopyWith<_$RazorpayIinImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

RazorpayIinList _$RazorpayIinListFromJson(Map<String, dynamic> json) {
  return _RazorpayIinList.fromJson(json);
}

/// @nodoc
mixin _$RazorpayIinList {
  int get count => throw _privateConstructorUsedError;
  List<String> get iins => throw _privateConstructorUsedError;

  /// Serializes this RazorpayIinList to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RazorpayIinList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RazorpayIinListCopyWith<RazorpayIinList> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RazorpayIinListCopyWith<$Res> {
  factory $RazorpayIinListCopyWith(
          RazorpayIinList value, $Res Function(RazorpayIinList) then) =
      _$RazorpayIinListCopyWithImpl<$Res, RazorpayIinList>;
  @useResult
  $Res call({int count, List<String> iins});
}

/// @nodoc
class _$RazorpayIinListCopyWithImpl<$Res, $Val extends RazorpayIinList>
    implements $RazorpayIinListCopyWith<$Res> {
  _$RazorpayIinListCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RazorpayIinList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? iins = null,
  }) {
    return _then(_value.copyWith(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      iins: null == iins
          ? _value.iins
          : iins // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RazorpayIinListImplCopyWith<$Res>
    implements $RazorpayIinListCopyWith<$Res> {
  factory _$$RazorpayIinListImplCopyWith(_$RazorpayIinListImpl value,
          $Res Function(_$RazorpayIinListImpl) then) =
      __$$RazorpayIinListImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int count, List<String> iins});
}

/// @nodoc
class __$$RazorpayIinListImplCopyWithImpl<$Res>
    extends _$RazorpayIinListCopyWithImpl<$Res, _$RazorpayIinListImpl>
    implements _$$RazorpayIinListImplCopyWith<$Res> {
  __$$RazorpayIinListImplCopyWithImpl(
      _$RazorpayIinListImpl _value, $Res Function(_$RazorpayIinListImpl) _then)
      : super(_value, _then);

  /// Create a copy of RazorpayIinList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? count = null,
    Object? iins = null,
  }) {
    return _then(_$RazorpayIinListImpl(
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
      iins: null == iins
          ? _value._iins
          : iins // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc

@JsonSerializable(includeIfNull: false)
class _$RazorpayIinListImpl implements _RazorpayIinList {
  const _$RazorpayIinListImpl(
      {required this.count, required final List<String> iins})
      : _iins = iins;

  factory _$RazorpayIinListImpl.fromJson(Map<String, dynamic> json) =>
      _$$RazorpayIinListImplFromJson(json);

  @override
  final int count;
  final List<String> _iins;
  @override
  List<String> get iins {
    if (_iins is EqualUnmodifiableListView) return _iins;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_iins);
  }

  @override
  String toString() {
    return 'RazorpayIinList(count: $count, iins: $iins)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RazorpayIinListImpl &&
            (identical(other.count, count) || other.count == count) &&
            const DeepCollectionEquality().equals(other._iins, _iins));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, count, const DeepCollectionEquality().hash(_iins));

  /// Create a copy of RazorpayIinList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RazorpayIinListImplCopyWith<_$RazorpayIinListImpl> get copyWith =>
      __$$RazorpayIinListImplCopyWithImpl<_$RazorpayIinListImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RazorpayIinListImplToJson(
      this,
    );
  }
}

abstract class _RazorpayIinList implements RazorpayIinList {
  const factory _RazorpayIinList(
      {required final int count,
      required final List<String> iins}) = _$RazorpayIinListImpl;

  factory _RazorpayIinList.fromJson(Map<String, dynamic> json) =
      _$RazorpayIinListImpl.fromJson;

  @override
  int get count;
  @override
  List<String> get iins;

  /// Create a copy of RazorpayIinList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RazorpayIinListImplCopyWith<_$RazorpayIinListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
